# fetch_token_addresses.py
from __future__ import annotations

import os
import sys
import re
import json
import tempfile
import zipfile
from pathlib import Path
from typing import Dict, List, Tuple

from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.remote.webdriver import WebDriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait

from src.sdk.queues.redis_connect import get_redis_sync as get_redis

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ö–æ–Ω—Ñ–∏–≥ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# –ü—Ä–æ–∫—Å–∏ —Ñ–æ—Ä–º–∞—Ç–∞: host:port:user:pass
SEL_PROXY = os.getenv("SEL_PROXY", "178.171.42.135:9056:t1d496:grovgA")

# URL –≤–∞—à–µ–≥–æ Selenium Grid/Standalone
# –ï—Å–ª–∏ –ø–æ compose –∏–∑ –≤–æ–ø—Ä–æ—Å–∞ –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç–µ —Å–æ —Å–≤–æ–µ–≥–æ —Ö–æ—Å—Ç–∞: http://localhost:4445/wd/hub
SELENIUM_SERVER_URL = os.getenv("SELENIUM_SERVER_URL", "http://localhost:4445/wd/hub")

# –û—á–µ—Ä–µ–¥–∏ –¥–ª—è —Ä–∞—Å–∫–ª–∞–¥–∫–∏ —Ç–æ–∫–µ–Ω–æ–≤ –ø–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º
FLAG_QUEUES: Dict[str, str] = {
    "PumpSwap": os.getenv("PUMP_QUEUE", "pump_queue"),
    "Raydium": os.getenv("RAYDIUM_QUEUE", "raydium_queue"),
    "Meteora": os.getenv("METEORA_QUEUE", "meteora_queue"),
}

# –ï—Å–ª–∏ "1" ‚Äî –æ—á–∏—Å—Ç–∏—Ç—å –æ—á–µ—Ä–µ–¥–∏ –ø–µ—Ä–µ–¥ –ø—É—à–µ–º
RESET_TOKENS_QUEUE = os.getenv("RESET_TOKENS_QUEUE", "0") == "1"

# –ö—É–¥–∞ —Å–ª–æ–∂–∏—Ç—å HTML-–¥–∞–º–ø —Ç–∞–±–ª–∏—Ü—ã (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
OUTPUT_DIR = Path(os.getenv("OUTPUT_DIR", "./dexscreener_out"))

# –°–∫–æ–ª—å–∫–æ —á–∞—Å–æ–≤ —Å–≤–µ–∂–µ—Å—Ç–∏ (–ø–∞—Ä–∞–º–µ—Ç—Ä maxAge –Ω–∞ dexscreener)
MAX_AGE_HOURS = int(os.getenv("MAX_AGE_HOURS", "24"))

# –ü—Ä–æ–≤–µ—Ä—è—Ç—å –≤–Ω–µ—à–Ω–∏–π IP —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏ (GET https://api.ipify.org)
CHECK_IP = os.getenv("CHECK_IP", "0") == "1"

# –í–∫–ª—é—á–∏—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è Selenium/Chrome
QUIET = os.getenv("QUIET", "1") == "1"

sys.stdout.reconfigure(line_buffering=True)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Redis ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def push_tokens(tokens: List[str], queue: str) -> None:
    if not tokens:
        return
    rds = get_redis()
    if RESET_TOKENS_QUEUE:
        rds.delete(queue)
        print(f"üßπ  –û—á–∏—Å—Ç–∏–ª–∏ –æ—á–µ—Ä–µ–¥—å {queue}")
    rds.rpush(queue, *tokens)
    print(f"üöö  –û—Ç–ø—Ä–∞–≤–∏–ª–∏ {len(tokens)} —Ç–æ–∫–µ–Ω–æ–≤ ‚Üí {queue}")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Proxy MV3 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def _parse_proxy(raw: str) -> Tuple[str, int, str, str]:
    """host:port:user:pass ‚Üí (host, port, user, pass)"""
    host, port, user, pwd = raw.split(":", 3)
    return host, int(port), user, pwd

def _build_auth_proxy_extension_zip(host: str, port: int, user: str, pwd: str) -> str:
    """
    –°–æ–∑–¥–∞—ë—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã–π ZIP c MV3-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º Chrome, –∫–æ—Ç–æ—Ä–æ–µ:
      - –∑–∞–¥–∞—ë—Ç fixed proxy (HTTP)
      - –æ—Ç–¥–∞—ë—Ç credentials –≤ onAuthRequired
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ zip.
    """
    manifest = {
        "name": "auth-proxy",
        "version": "1.0",
        "manifest_version": 3,
        "permissions": [
            "proxy",
            "storage",
            "webRequest",
            "webRequestAuthProvider"
        ],
        "host_permissions": ["<all_urls>"],
        "background": {"service_worker": "background.js"},
        "minimum_chrome_version": "110"
    }

    background_js = f"""// generated
chrome.proxy.settings.set({{
  value: {{
    mode: "fixed_servers",
    rules: {{
      singleProxy: {{ scheme: "http", host: "{host}", port: {port} }},
      bypassList: ["localhost","127.0.0.1"]
    }}
  }},
  scope: "regular"
}}, () => {{}});

// MV3: asyncBlocking –¥–ª—è –≤–≤–æ–¥–∞ –ª–æ–≥–∏–Ω–∞/–ø–∞—Ä–æ–ª—è
chrome.webRequest.onAuthRequired.addListener(
  (details, callback) => {{
    callback({{authCredentials: {{username: "{user}", password: "{pwd}"}}}});
  }},
  {{ urls: ["<all_urls>"] }},
  ["asyncBlocking"]
);
"""

    tmpdir = tempfile.mkdtemp(prefix="pxyext_")
    zippath = os.path.join(tmpdir, "proxy_auth_ext.zip")
    with zipfile.ZipFile(zippath, "w", zipfile.ZIP_DEFLATED) as z:
        z.writestr("manifest.json", json.dumps(manifest, ensure_ascii=False))
        z.writestr("background.js", background_js)
    return zippath

def _make_driver() -> WebDriver:
    host, port, user, pwd = _parse_proxy(SEL_PROXY)
    ext_zip = _build_auth_proxy_extension_zip(host, port, user, pwd)

    opts = webdriver.ChromeOptions()

    # –ë–∞–∑–æ–≤—ã–µ —Ñ–ª–∞–≥–∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
    opts.add_argument("--no-sandbox")
    opts.add_argument("--disable-dev-shm-usage")
    opts.add_argument("--disable-gpu")
    opts.add_argument("--disable-infobars")
    opts.add_argument("--disable-features=BlockInsecurePrivateNetworkRequests")
    opts.add_argument("--disable-quic")  # –∏–∑–±–µ–≥–∞–µ–º QUIC, —á—Ç–æ–±—ã —Ç—Ä–∞—Ñ–∏–∫ —Ç–æ—á–Ω–æ —à—ë–ª —á–µ—Ä–µ–∑ HTTP-–ø—Ä–æ–∫—Å–∏

    # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —è–≤–Ω—ã–π —è–∑—ã–∫/UA –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏:
    # opts.add_argument("--lang=ru-RU")

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º MV3-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å –ø—Ä–æ–∫—Å–∏-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π
    opts.add_extension(ext_zip)

    if QUIET:
        # –ß—É—Ç—å —Ç–∏—à–µ –ª–æ–≥–∏ –¥–∏—Å–ø–ª–µ—è/–∫—Ä–æ—à–µ–∫
        opts.add_experimental_option("excludeSwitches", ["enable-logging"])
        opts.add_experimental_option("useAutomationExtension", False)

    driver = webdriver.Remote(
        command_executor=SELENIUM_SERVER_URL,
        options=opts
    )
    return driver

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–∂–∏–¥–∞–Ω–∏—è/—Å—Ç—Ä–∞–Ω–∏—Ü—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def _wait_table(driver: WebDriver, timeout: int = 600):
    """–ñ–¥—ë–º –ø–æ—è–≤–ª–µ–Ω–∏—è –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –ø–æ—Å–ª–µ –∫–∞–ø—á–∏."""
    sel = "div.ds-dex-table.ds-dex-table-top"
    return WebDriverWait(driver, timeout).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, sel))
    )

def _check_ip(driver: WebDriver) -> None:
    try:
        driver.get("https://api.ipify.org?format=text")
        WebDriverWait(driver, 20).until(
            EC.presence_of_element_located((By.TAG_NAME, "pre"))
        )
        ip = driver.find_element(By.TAG_NAME, "pre").text
        print(f"[ip] {ip}")
    except Exception as e:
        print(f"[ip] check failed: {e}")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ü–∞—Ä—Å–µ—Ä HTML ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

_token_src_re = re.compile(r"/tokens/solana/([A-Za-z0-9]+)\.png", re.IGNORECASE)
FLAGS = list(FLAG_QUEUES.keys())  # ["PumpSwap", "Raydium", "Meteora"]

def extract_tokens_by_flag(html: str, flags: List[str] = FLAGS) -> Dict[str, List[str]]:
    """
    –°–∫—Ä–µ–π–ø –∞–¥—Ä–µ—Å–∞ —Ç–æ–∫–µ–Ω–æ–≤ –ø–æ –∫–∞–∂–¥–æ–º—É –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–µ–º—É —Ñ–ª–∞–≥—É.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç {flag: [addr, ‚Ä¶]}.
    """
    soup = BeautifulSoup(html, "html.parser")
    result: Dict[str, List[str]] = {flag: [] for flag in flags}
    flag_set = {f.lower() for f in flags}

    for row in soup.select("a.ds-dex-table-row"):
        # –ù–∞–π–¥—ë–º, –∫ –∫–∞–∫–æ–º—É –∏—Å—Ç–æ—á–Ω–∏–∫—É –æ—Ç–Ω–æ—Å–∏—Ç—Å—è —Å—Ç—Ä–æ–∫–∞ (–ø–æ –∑–Ω–∞—á–∫—É —Å title)
        titles = [img.get("title", "").strip().lower() for img in row.select("img[title]")]
        found = next((t for t in titles if t in flag_set), None)
        if not found:
            continue
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∏–º—è —Ñ–ª–∞–≥–∞ –∫–∞–∫ –≤ –∫–ª—é—á–∞—Ö —Å–ª–æ–≤–∞—Ä—è
        flag_found = next(f for f in flags if f.lower() == found)

        # –ò—â–µ–º –∏–∫–æ–Ω–∫—É —Ç–æ–∫–µ–Ω–∞ ‚Üí –∞–¥—Ä–µ—Å –≤ src
        icon = row.select_one("img.ds-dex-table-row-token-icon-img[src*='/tokens/solana/']")
        if not icon:
            continue
        m = _token_src_re.search(icon["src"])
        if m:
            result[flag_found].append(m.group(1))

    # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏, —Å–æ—Ö—Ä–∞–Ω—è—è –ø–æ—Ä—è–¥–æ–∫
    for flag, lst in result.items():
        result[flag] = list(dict.fromkeys(lst))
    return result

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –°–∫—Ä–µ–π–ø–µ—Ä ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def run(max_age_hours: int, out_dir: Path) -> str:
    """
    –û—Ç–∫—Ä—ã–≤–∞–µ—Ç DexScreener, –∂–¥—ë—Ç —Ç–∞–±–ª–∏—Ü—É (–ø–æ—Å–ª–µ —Ä—É—á–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è –∫–∞–ø—á–∏ —á–µ—Ä–µ–∑ VNC),
    –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç HTML —Ç–∞–±–ª–∏—Ü—ã.
    """
    url = (
        "https://dexscreener.com/solana"
        f"?rankBy=trendingScoreH6&order=desc&minMarketCap=50000&maxAge={max_age_hours}"
    )
    print("[open]", url)

    driver = _make_driver()
    try:
        if CHECK_IP:
            _check_ip(driver)

        driver.get(url)
        print("[wait] –†–µ—à–∏—Ç–µ CAPTCHA –≤ noVNC; –∂–¥—ë–º —Ç–∞–±–ª–∏—Ü—É‚Ä¶")
        table_el = _wait_table(driver)

        out_dir.mkdir(parents=True, exist_ok=True)
        html = table_el.get_attribute("outerHTML") or ""
        (out_dir / "last_table.html").write_text(html, encoding="utf-8")
        print(f"[save] {out_dir / 'last_table.html'}")
        return html
    finally:
        try:
            driver.quit()
        except Exception:
            pass
        print("[quit] browser closed")

def run_and_push(max_age_hours: int, out_dir: Path) -> Dict[str, List[str]]:
    html = run(max_age_hours, out_dir)
    tokens_by_flag = extract_tokens_by_flag(html)

    for flag, tokens in tokens_by_flag.items():
        push_tokens(tokens, FLAG_QUEUES[flag])

    return tokens_by_flag

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CLI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

if __name__ == "__main__":
    tokens_by_flag = run_and_push(MAX_AGE_HOURS, OUTPUT_DIR)
    for flag, tokens in tokens_by_flag.items():
        print(f"\n{flag} addresses ({len(tokens)}):")
        print("\n".join(tokens))
